<!– Snake: Start erst nach Klick –>
<div id=“snake-wrap“ style=“max-width: 420px;margin: 1rem auto;font-family: system-ui, sans-serif;“>
<div style=“display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem;“>
<strong>Snake</strong>
<div>
Score: <span id=“score“>0</span>
<button id=“restart“ style=“margin-left:.5rem;padding:.25rem .6rem;“>Neu</button>
</div>
</div>
<canvas id=“snake“ width=“400″ height=“400″ style=“width:100%;background:#111;border-radius:8px;display:block;touch-action:none;“></canvas>
<p style=“font-size:.9rem;color:#666;margin:.5rem 0 0;“>
Steuerung: Pfeiltasten / WASD • Mobil: Wischen
</p>
</div>

<script>
(() => {
const canvas = document.getElementById(’snake‘);
const ctx = canvas.getContext(‚2d‘);
const scoreEl = document.getElementById(’score‘);
const restartBtn = document.getElementById(‚restart‘);

const size = 20;
const cells = canvas.width / size;
const speedStart = 120;
const speedMin = 60;
const growPerApple = 1;

let snake, dir, nextDir, apple, score, tickMs, loopId, isRunning, hasStarted;

function init() {
snake = [{x: 8, y: 10}, {x:7, y:10}, {x:6, y:10}];
dir = {x:1,y:0}; nextDir = {x:1,y:0};
apple = spawnApple();
score = 0; scoreEl.textContent = score;
tickMs = speedStart;
isRunning = true;
clearInterval(loopId);
loopId = setInterval(tick, tickMs);
draw();
}

function spawnApple() {
let pos;
do {
pos = { x: Math.floor(Math.random()*cells), y: Math.floor(Math.random()*cells) };
} while (snake.some(s => s.x===pos.x && s.y===pos.y));
return pos;
}

function setDir(nx, ny) {
if (nx === -dir.x && ny === -dir.y) return;
nextDir = {x:nx,y:ny};
}

function tick() {
if (!isRunning) return;
dir = nextDir;
const head = { x: (snake[0].x + dir.x + cells) % cells,
y: (snake[0].y + dir.y + cells) % cells };

if (snake.some((s,i) => i && s.x===head.x && s.y===head.y)) {
gameOver(); return;
}

snake.unshift(head);

if (head.x === apple.x && head.y === apple.y) {
score += 1; scoreEl.textContent = score;
apple = spawnApple();
tickMs = Math.max(speedMin, speedStart – score*4);
clearInterval(loopId);
loopId = setInterval(tick, tickMs);
for (let i=0;i<growPerApple;i++) snake.push({…snake[snake.length-1]});
} else {
snake.pop();
}

draw();
}

function draw() {
ctx.fillStyle = ‚#111‘;
ctx.fillRect(0,0,canvas.width,canvas.height);

// Apfel
ctx.fillStyle = ‚#e53‘;
roundRect(apple.x*size+2, apple.y*size+2, size-4, size-4, 5);

// Snake
for (let i=0;i<snake.length;i++) {
const s = snake[i];
ctx.fillStyle = i===0 ? ‚#6cf‘ : ‚#2dd‘;
roundRect(s.x*size+2, s.y*size+2, size-4, size-4, 4);
}
}

function roundRect(x,y,w,h,r) {
ctx.beginPath();
ctx.moveTo(x+r,y);
ctx.arcTo(x+w,y,x+w,y+h,r);
ctx.arcTo(x+w,y+h,x,y+h,r);
ctx.arcTo(x,y+h,x,y,r);
ctx.arcTo(x,y,x+w,y,r);
ctx.closePath();
ctx.fill();
}

function drawStartScreen() {
ctx.fillStyle = ‚#111‘;
ctx.fillRect(0,0,canvas.width,canvas.height);
ctx.fillStyle = ‚#6cf‘;
ctx.font = ‚bold 28px system-ui, sans-serif‘;
ctx.textAlign = ‚center‘;
ctx.fillText(‚Snake‘, canvas.width/2, canvas.height/2 – 20);
ctx.font = ’16px system-ui, sans-serif‘;
ctx.fillStyle = ‚#ccc‘;
ctx.fillText(‚Klick / Tippen zum Start‘, canvas.width/2, canvas.height/2 + 10);
}

function gameOver() {
isRunning = false;
clearInterval(loopId);
ctx.fillStyle = ‚rgba(0,0,0,.5)‘;
ctx.fillRect(0,0,canvas.width,canvas.height);
ctx.fillStyle = ‚#fff‘;
ctx.font = ‚bold 28px system-ui, sans-serif‘;
ctx.textAlign = ‚center‘;
ctx.fillText(‚Game Over‘, canvas.width/2, canvas.height/2 – 10);
ctx.font = ’16px system-ui, sans-serif‘;
ctx.fillText(‚Klick / Tippen oder „Neu“ für Restart‘, canvas.width/2, canvas.height/2 + 18);
}

// Eingaben
window.addEventListener(‚keydown‘, (e) => {
if (!hasStarted) return;
const k = e.key.toLowerCase();
if (k===’arrowup‘ || k===’w‘) setDir(0,-1);
else if (k===’arrowdown‘ || k===’s‘) setDir(0,1);
else if (k===’arrowleft‘ || k===’a‘) setDir(-1,0);
else if (k===’arrowright‘ || k===’d‘) setDir(1,0);
else if (k===‘ ‚ && !isRunning) init();
});

// Wischgesten
let touchStart = null;
canvas.addEventListener(‚touchstart‘, (e) => {
const t = e.changedTouches[0];
touchStart = {x: t.clientX, y: t.clientY};
}, {passive:true});
canvas.addEventListener(‚touchend‘, (e) => {
if (!hasStarted) { hasStarted = true; init(); return; }
if (!touchStart) return;
const t = e.changedTouches[0];
const dx = t.clientX – touchStart.x;
const dy = t.clientY – touchStart.y;
const ax = Math.abs(dx), ay = Math.abs(dy);
if (Math.max(ax,ay) < 20) return;
if (ax > ay) setDir(dx>0 ? 1 : -1, 0);
else setDir(0, dy>0 ? 1 : -1);
touchStart = null;
}, {passive:true});

// Klick-Start & Restart
canvas.addEventListener(‚click‘, () => {
if (!hasStarted) { hasStarted = true; init(); return; }
if (!isRunning) init();
});

restartBtn.addEventListener(‚click‘, () => {
hasStarted = true;
init();
});

// Fokus für Keyboard
canvas.setAttribute(‚tabindex‘, ‚0‘);
canvas.addEventListener(‚pointerdown‘, () => canvas.focus());
canvas.focus();

// Startbildschirm anzeigen
drawStartScreen();
})();
</script>
